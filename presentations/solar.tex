\documentclass{beamer}
\usetheme{Copenhagen}
\setbeamertemplate{page number in head/foot}{}
\usepackage{dirtytalk}
\usepackage{listings}
\input{solidity_support}
\newcommand{\hole}{\textit{choose}}

%Information to be included in the title page:
\title[]{Summary-Based Symbolic Execution for Smart Contracts (ASE'20)}
\subtitle{Yu Feng, Emina Torlak \& Ratislav Bodik}
\author{Manasvi Saxena}

\setbeamerfont{caption}{size=\scriptsize}
\date{}
\begin{document}

\frame{\titlepage}

\section{Introduction}

\begin{frame}
  \frametitle{Motivation}
  \begin{itemize}
    \item \textit{Smart Contracts} find increasing adoption.
      Ethereum has ~45M contracts in
      \textit{finance}, \textit{gaming}, \textit{e-commerce}.
    \item Code on the blockchain \textit{immutable}. Critical
      issues cannot be \textit{patched} after deployment.
    \item Successful attacks have serious consequences:
      \begin{itemize}
        \item In 2016 \textit{Reentrace} bug lead to loss of ~\$150M and a hard
          fork.
        \item In 2017, \textit{Incorrect Permissions} lead to a loss of ~\$30M
        \item In 2018, \textit{Overflow} errors caused multiple tokens to shutdown
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Challenges}
  \begin{itemize}
    \item Vulnerabilities may be \textit{intra}-contract or
      \textit{inter}-contract.
      \begin{itemize}
        \item Need to analyze both contract and
          interations with external accounts.
      \end{itemize}
    \item Multiple High Level Languages (Solidity, Vyper) compile to a
      stack based instruction set (EVM)
      \begin{itemize}
        \item Rapidly evolving ecosytem makes \textit{platform indepenence}
          important.
      \end{itemize}
    \item Widespread adoption requires a balance of
      \textit{strong guarantees}, \textit{ease of use} and \textit{automation}
      \begin{itemize}
        \item Verification may not be feasible due to lack of expertise
      \end{itemize}
    \item \textit{Configurable} and \textit{scalable} to detect multiple kinds of bugs
      in non-trivial contracts
      \begin{itemize}
        \item Checking for common anti-patterns alongside
          tests increase confidence in correctness
        \item Performance should not act as a bottleneck
          in development cycle.
      \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Contributions}
  \textit{SOLAR} Synthesis tool for adversarial contracts
  to expose vulnerabilities
  \begin{itemize}
    \item Uses \say{Summary-Based Symbolic Execution} for \textit{Scalablity}
    \begin{itemize}
      \item Summaries drastically cuts execution instructions
    \end{itemize}
    \item Handles \textit{inter-contract} interactions
    \item Mostly \textit{automated}, though may require intervention
      in some cases
    \item Can be configured to detect different classes of vulnerabilities.
   \item \textit{Platform Independent} as it works over the bytecode
      instead of HLL like \textit{Solidity}, \textit{Serpent}
  \end{itemize}
\end{frame}

\section{Background}
\subsection{Smart Contracts and EVM}
\begin{frame}
  \frametitle{Background}
  \begin{block}{Smart Contracts}
    \begin{itemize}
      \item Program on second generation blockchains that are executed
        during transactions.
      \item Accounts have \textit{persistent storage} and hold \textit{coins}.
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{Ethereum}
    \begin{itemize}
      \item \textit{Ethereum Virtual Machine} Network nodes
        understand a low level stack based language called \textit{EVM}
      \item Contracts written in High Level Languages (HLL) and compiled to EVM.
      \item The \textit{ABI} specifies convention for calling a contract
    \end{itemize}
  \end{block}
\end{frame}

\subsection{Examples}
\begin{frame}[fragile]
  \frametitle{Reentrace Vulnerability}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{lstlisting}[numbers = none, language=Solidity, style=transitions]
      contract Victim {
        // ...
        function withdraw(unit a) {
          if(balances[msg.sender] >= a) {
            @msg.sender.call.value(a);@
            balances[msg.sender] -= a;
          }
        }
      }
      \end{lstlisting}
    \end{column}

    \begin{column}{0.5\textwidth}
      \begin{lstlisting}[language=Solidity, style=transitions, numbers=none]
      contract Attacker {
        Victim v;

        function exploit() {
          v = Victim(0x123);
          v.withdraw();
        }

        function payable() {
          @v.withdraw(10);@
        }
      }
      \end{lstlisting}
    \end{column}
  \end{columns}
  \begin{itemize}
    \item<2-> Within \textit{payable}, attacker calls \textit{withdraw}
      before victim updates persistent storage
    \item<2-> Trace \textit{transfer,transfer, ..., sstore} observed
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Detection with SOLAR}
  Inputs to SOLAR - \textit{Attack template} and a \textit{Query}

  \begin{columns}[T]
    \begin{column}{0.4\textwidth}
      \center{\scriptsize{\textbf{Attack Template}}}
      \begin{lstlisting}[language=Solidity, style=transitions, numbers=none]
      contract Attacker {
        Victim v;

        function exploit() {
          v = Victim(0x123);
          ?? // Hole
        }

        function payable() {
          ?? // Hole
        }
      }
      \end{lstlisting}
    \end{column}
      \pause
    \begin{column}{0.6\textwidth}
      \center{\scriptsize{\textbf{Query}}}
      \begin{lstlisting}[language=Solar, numbers=none]
        uses Transfer $t_1$, $t_2$; Store s; Argument a;
        matches {$t_1$; ~s; $t_2$}
          where ($t_1$.loc == $t_2$.loc)
            $\wedge$ ($t_2$.gas > 2300)
            $\wedge$ (interfere? a $t_2$.reciepient)
      \end{lstlisting}
    \end{column}
  \end{columns}
  \pause
  \begin{itemize}
    \item \scriptsize{SOLAR Synthesizes a \textit{Concrete Attack Program} that
      satisfies \textit{Query}}.
    \item \scriptsize{\textit{Holes} in the \textit{Template} replaced with
      \textit{ABI calls} that satisfy \textit{Query}.}
\end{itemize}
\end{frame}
\begin{frame}
  \frametitle{SOLAR Overview}
  SOLAR's synthesis works as following:
  \begin{itemize}
    \item Encode holes as \textit{choose statements} $\hole(\tau_1, \tau_2, \dots, \tau_n)$
      where $\tau_i$ is a tuple of the name and argument types
      of a method in the victim.
    \item The attack program is a sequence of $k$ statements.
      For $n$ public victim methods, SOLAR considers $n^k$
      programs.
    \item Symbolically executes the attack program on a state
      where victim identifier are bound to \textit{fresh variables}.
    \item Attempts to find a concrete call statements that satisfy \textit{Query}

  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{SOLAR Optimizations}
  SOLAR uses two optimizations:
      \begin{itemize}
        \item \textbf{Hoisting}
        \begin{itemize}
          \item $\hole(\tau_1, \tau_2)$ is sugar for
            $\text{if}(b_i) \tau_1 \text{else} \tau_2$,
            where $b_i$ is bound to a fresh variable.
          \item SOLAR \textit{hoists} over \textit{choose statements} by
            enumerating all possible attack programs.
          \item \textit{Hoisted} programs can be executed concurrently
      \end{itemize}
    \item \textbf{Summary Based Execution}
      \begin{itemize}
        \item SOLAR calculates \textit{summaries} for victim's
          methods for symbolic execution
      \end{itemize}
  \end{itemize}
\end{frame}



\section{Problem Formalization}
\subsection{SOLAR Intermediate Representation}
\begin{frame}
\begin{itemize}
  \item EVM is stack-based and low level, making it
    unsuitable for

\end{itemize}
\end{frame}


\end{document}

